A file that is obviously a text file, with a binary file extension

// Copyright: John McDonald 1990 - 2020
// MS Pascal version created 1990.
// C# version created 2007 - 2011.
// Scala version created 2016.
// Delphi version created May 2018.
//
// Minor change

unit StrataSort;

interface

uses
  SysUtils, System.Classes, Generics.Defaults, Generics.Collections;

type
  /// <summary>
  /// A stable sort algorithm. ~O(n.log(n)), seems reasonably fast.
  /// The sort may be a little faster for presorted, almost sorted, and reverse sequence inputs.
  /// For most of the sort, lists of equal lengths are being merged.
  /// One of the lists being merged is contained in a SortStackItem,
  /// the other is made up of all the items in the previous SortStackItems.
  /// </summary>
  TStrataSort<T> = class
  strict private
    /// <summary>
    /// The SortStack contains a list of these items. Each SortStackItem can contain SortItems.
    /// The first SortStackItem can contain 1, the second 1, the third 2, the fourth 4, and so on.
    /// Apart from the first, each SortStackItem can contain 2^(n-1) SortItems, where n is its index in the SortStack.
    /// Each SortStackItem can contain the same number of items as all the SortStackItems below it.
    /// Each SortStackItem contains pointers to the SortStackItem below it in the SortStack.
    /// </summary>
    type  TSortStackItem = class
    strict private
      SortCompare: TComparison<T>;
      PrevStackItem: TSortStackItem;    // A reference to the SortStackItem below this in the SortStack.
      SortItems: array of T;    // An array of Max(1, 2*(n-1)) SortItems, where n is the index of this SortStackItem in the SortStack.
      FCount: Integer;    // count of valid items in sortItems. ( there may still be obsolete items left in sortItems )
      // The following three fields; FIndex, FCurrent and FEof are only valid after GetFirst or GetNext has been called.
      FIndex: Integer;    // The index of the next item in sortItems.
      FEof: Boolean;      // True when there are no more items at this or lower levels that haven't already been passed up to higher levels.
      FCurrent: T;        // The current item in the sort from either sortItems or prevStackItem.
                          // FCurrent is the earliest item that we know about at this level, that hasn't already been passed up to a higher level.
    public
      constructor Create(const ACapacity: Integer;
                         const APrevStackItem: TSortStackItem;
                         const ASortCompare: TComparison<T>);
      procedure Clear;
      procedure AddSingleItem(const Item: T); inline;
      procedure GetNext;
      procedure GetFirst;
      procedure RecoverNext;
      procedure RecoverFirst;
      procedure LoadFromPreviousLevels;
      property Count: Integer read FCount;
      property Current: T read FCurrent;    // Eof is only valid after GetFirst or GetNext has been called.
      property Eof: Boolean read FEof;    // Eof is only valid after GetFirst or GetNext has been called.
    end;

  private
    /// <summary>
    /// This record type is just used to allow the sort to work with an IComparer<T>.
    /// </summary>
    type  TComparerInterfaceAdapter = record
    strict private
      FComparer: IComparer<T>;
    public
      constructor Create(const AComparer: IComparer<T>);
      function Compare(const Left, Right: T): Integer;
    end;
  strict private
    SortCompare: TComparison<T>;
    SortStack: TObjectList<TSortStackItem>;
    FirstSortStackItem: TSortStackItem;
    StackTop: Integer;
    TopSortStackItem: TSortStackItem;    // TopSortStackItem is null before RunSort and assigned after.
    procedure Clear;
    procedure GetNext; inline;
    procedure RecoverFirst;
    procedure RecoverNext;
    function  GetCurrent: T; inline;
    function  GetEof: Boolean; inline;
    procedure SortRelease(const Item: T);
    function  SortReturn: T; inline;
    procedure FailSafeRecovery(const AList: TList<T>);
    property Current: T read GetCurrent;
  public
    constructor Create; overload;  deprecated 'SortCompare or SortComparer parameter is required.';
    constructor Create(const ASortCompare: TComparison<T>); overload;
    constructor Create(const ASortComparer: IComparer<T>); overload;
    destructor Destroy; override;
    procedure Release(const Item: T); inline;
    procedure RunSort;
    function  Return: T; inline;
    procedure Sort(const AList: TList<T>); overload;
    procedure Sort(const ASourceList: TList<T>;
                   const ADestinationList: TList<T>); overload;
    property Eof: Boolean read GetEof;
  end;

  TStrataSort = class
  public
    class procedure Sort<T>(const AList: TList<T>;
                            const ASortCompare: TComparison<T>); overload;
    class procedure Sort<T>(const AList: TList<T>;
                            const ASortComparer: IComparer<T>); overload;
    class procedure Sort<T>(const ASourceList: TList<T>;
                            const ADestinationList: TList<T>;
                            const ASortCompare: TComparison<T>); overload;
    class procedure Sort<T>(const ASourceList: TList<T>;
                            const ADestinationList: TList<T>;
                            const ASortComparer: IComparer<T>); overload;
  end;

type
  ESortError = class(Exception);

implementation

{ TStrataSort<T>.TSortStackItem }

constructor TStrataSort<T>.TSortStackItem.Create(const ACapacity: Integer;
                                                 const APrevStackItem: TSortStackItem;
                                                 const ASortCompare: TComparison<T>);
begin
  inherited Create;
  SortCompare := ASortCompare;
  PrevStackItem := APrevStackItem;
  SetLength(SortItems, ACapacity);
  FCount := 0;
  FIndex := -1;
  FCurrent := Default(T);
  FEof := True;
end;

procedure TStrataSort<T>.TSortStackItem.Clear;
begin
  FCount := 0;
  FIndex := -1;
  FCurrent := Default(T);
  FEof := True;
  if Assigned(PrevStackItem) then
    PrevStackItem.Clear;
end;

// This should only be called for the first SortStackItem in the SortStack.
procedure TStrataSort<T>.TSortStackItem.AddSingleItem(const Item: T);
begin
  SortItems[0] := Item;
  FCount := 1;
end;

/// This will set Current, FIndex and Eof.
/// Note that Current will never be the same item in more than one SortStackItem.
procedure TStrataSort<T>.TSortStackItem.GetNext;
begin
  if ( PrevStackItem = nil ) or
     PrevStackItem.Eof then
  begin
    if FIndex >= Count then
    begin
      FEof := True;
      FCurrent := Default(T);
    end
    else
    begin
      FCurrent := SortItems[FIndex];
      Inc(FIndex);
    end;
  end
  else if FIndex >= Count then
  begin
    FCurrent := PrevStackItem.Current;
    PrevStackItem.GetNext;
  end
  else
  begin
    if SortCompare(SortItems[FIndex], PrevStackItem.Current) <= 0 then
    begin
      FCurrent := SortItems[FIndex];
      Inc(FIndex);
    end
    else
    begin
      FCurrent := PrevStackItem.Current;
      PrevStackItem.GetNext;
    end;
  end;
end;

// This method will prepare this level and levels below it for merging.
// It sets up FIndex, FCurrent and FEof.
procedure TStrataSort<T>.TSortStackItem.GetFirst;
begin
  if Assigned(PrevStackItem) then
  begin
    PrevStackItem.GetFirst;
  end;
  FIndex := 0;
  FEof := False;
  GetNext;
end;

